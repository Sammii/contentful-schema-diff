
import * as fs from 'fs-extra'
import * as path from 'path'
import {exec} from 'child_process'

import { IContentType } from './model'
import { asyncWriter, indexById, wait } from './utils';
import { writeCreate } from './create';
import { writeModify } from './modify';
import { writeDelete } from './delete';
import { Writable } from 'stream';

export interface IArgs {
  from: string,
  to: string,
  oneFile: boolean,
  outDir: string
}

export default async function Run(args: IArgs) {

  const [from, to] = await loadSources(args.from, args.to)

  const fromTypes = indexById(from)
  const toTypes = indexById(to)

  const HEADER = `import Migration from 'contentful-migration-cli'

// Generated by contentful-schema-diff
// from ${args.from}
// to   ${args.to}
export = function (migration: Migration) {
`

  const FOOTER =`
}
`

  const runner = args.oneFile ?
    new WriteSingleFileRunner(args.outDir, HEADER, FOOTER) :
    new FilePerContentTypeRunner(args.outDir, HEADER, FOOTER)

  await runner.init()

  const promises = runner.run(Object.keys(toTypes), async (id, chunkWriter) => {
    if (fromTypes[id]) {
      await writeModify(fromTypes[id], toTypes[id], chunkWriter)
    } else {
      await writeCreate(toTypes[id], chunkWriter)
    }
  })
  promises.push(...runner.run(Object.keys(fromTypes), async (id, chunkWriter) => {
    if (toTypes[id]) {
      // handled above in 'writeModify'
      return
    }
    
    writeDelete(id, chunkWriter)
  }))

  await Promise.all(promises)

  await runner.close();
}

type AsyncWrite = (chunk: string) => Promise<any> 

class WriteSingleFileRunner {
  fileName: string
  fileWriter: AsyncWrite
  outputStream: fs.WriteStream
  header: string
  footer: string

  constructor(outDir: string, header: string, footer: string) {
    this.fileName = path.join(outDir, `${new Date().toISOString().replace(/[^\d]/g, '').substring(0, 14)}_generated_from_diff.ts`)
    this.outputStream = fs.createWriteStream(this.fileName)
    this.fileWriter = asyncWriter(this.outputStream)
    this.header = header
    this.footer = footer
  }  

  async init() {
    await this.fileWriter(this.header)
  }

  run(keys: string[], run: (id: string, write: AsyncWrite) => Promise<void>): Promise<void>[] {
    return keys.map(async (id: string) => {
      let chunks: string[] = []

      await run(id, (chunk: string) => Promise.resolve(chunks.push(chunk)))

      if (chunks.length > 0) {
        const header =`
  /************  ${id}  ******************/
`
        await this.fileWriter(header + chunks.join(''))
      }
    })
  }

  async close() {
    await this.fileWriter(this.footer)
    this.outputStream.close();
    await wait(1)
    await formatFile(this.fileName)
    console.log('wrote file', this.fileName)
  }
}

class FilePerContentTypeRunner {
  outDir: string
  header: string
  footer: string

  streams: { stream: fs.WriteStream, writer: AsyncWrite, fileName: string }[] = []

  constructor(outDir: string, header: string, footer: string) {
    this.outDir = outDir
    this.header = header
    this.footer = footer
  }

  async init() {

  }

  run(keys: string[], run: (id: string, write: AsyncWrite) => Promise<void>): Promise<void>[] {
    return keys.map(async (id: string) => {
      const writer = this.makeWriter(id)

      await run(id, writer)
    })
  }

  async close() {
    this.streams.map(async tuple => {
      await tuple.writer(this.footer)
      tuple.stream.close()
      await wait(1)
      await formatFile(tuple.fileName)
      console.log('wrote file', tuple.fileName)
    })
  }

  private makeWriter(id: string): AsyncWrite {
    let stream: fs.WriteStream = undefined
    let writer: AsyncWrite
    let fileName: string

    return async (chunk: string) => {
      // don't open the file stream until first write
      if (!stream) {
        fileName = path.join(this.outDir, `${new Date().toISOString().replace(/[^\d]/g, '').substring(0, 14)}_generated_diff_${id.underscore()}.ts`)
        stream = fs.createWriteStream(fileName)
        writer = asyncWriter(stream)
        this.streams.push({ stream, writer, fileName })

        await writer(this.header)
      }

      writer(chunk)
    }
  }
}

function formatFile(file: string): Promise<void> {
  const tsFmtBinLocation = path.join(require.resolve('typescript-formatter'), '../../.bin/tsfmt')
  const tsfmtConfigFile = path.relative(process.cwd(), path.join(__dirname, '../tsfmt.json'))

  return new Promise((resolve, reject) => {
    exec(`${tsFmtBinLocation} -r ${file} --useTsfmt ${tsfmtConfigFile}`, (err, stdout, stderr) => {
      if(err) {
        reject(err.message + '\n\t' + stderr)
      } else {
        resolve()
      }
    })
  })
}

function loadSources(from: string, to: string): Promise<IContentType[][]> {
  return Promise.all([
    loadSource(from),
    loadSource(to)
  ])
}

async function loadSource(source: string): Promise<IContentType[]> {
  if (await fs.pathExists(source)) {
    const contents = await fs.readFile(source)
    return JSON.parse(contents.toString()).contentTypes
  }

  throw new Error(`${source} is not a file!`)
}